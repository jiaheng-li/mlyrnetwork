theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
a = rcpp_compute_dyad_suffstats(mlnet$net, 1, 100, intv, mdim, mterm, N, k, H, seed, basis_arguments)
a
colSums(a$dyad_suffstats)
apply(a$dyad_suffstats,2,sd)
mlnet$suff_stats
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
RNETWORK <- rcpp_simulate_ml_Hway(samp_num, burnin, intv, mdim, mterm, N, k, theta, H, seed, basis_arguments)
samp_num=1
RNETWORK <- rcpp_simulate_ml_Hway(samp_num, burnin, intv, mdim, mterm, N, k, theta, H, seed, basis_arguments)
NetMat <- RNETWORK$elist
NetMat
iter_max = 30000
result <- rcpp_estimate_model_ml_Hway(NetMat, samp_num,  burnin, intv, mdim, mterm, N, k,H, seed,basis_arguments, iter_max)
# calculate covariance matrix of mple by sufficient statistics
a <- rcpp_compute_dyad_suffstats(NetMat, samp_num, burnin, intv, mdim, mterm, N, k, H, seed,basis_arguments)
a
a$dyad_suffstats
df[,3:mdim]
suff_matrix <- a$dyad_suffstats
df <- data.frame(suff_matrix)
df
df[,3:mdim]
rowSums(df[,3:(mdim+2)])
rowSums(df[,3:(mdim+2)])>0
cond_suff_mat <- df[rowSums(df[,3:(mdim+2)]) > 0,]
cond_suff_mat
rowSums(df[,3:(mdim+2)]) ==0
# only count sufficient statistics of the activated dyad
cond_suff_mat <- df[rowSums(df[,3:(mdim+2)]) > 0,]
mple_cov <- cov(cond_suff_mat[,3:(mdim+2)])
mple_cov
num_of_dyad <- length(cond_suff_mat[,1])
dist_mat <- data.frame(result)
values <- rep(0,mdim)
for (i in c(1:mdim)){
values[i] <- dist_mat[i,1]
}
RL2err <- norm(values - theta, "2")/norm(theta,"2")
# Prepare result list
res <- list(theta = theta,theta_est = values, RL2err = RL2err, suff_matrix = suff_matrix,
time = as.numeric(difftime(toc, tic, units = "secs")), seed = seed, net_size = N, num_of_layers = k, highest_order = H,
num_of_dyad = num_of_dyad, mple_cov = mple_cov, basis_net = basis_arguments)
tic <- Sys.time()
toc <- Sys.time()
# Prepare result list
res <- list(theta = theta,theta_est = values, RL2err = RL2err, suff_matrix = suff_matrix,
time = as.numeric(difftime(toc, tic, units = "secs")), seed = seed, net_size = N, num_of_layers = k, highest_order = H,
num_of_dyad = num_of_dyad, mple_cov = mple_cov, basis_net = basis_arguments)
View(res)
res$mple_cov
solve(res$mple_cov)
num_of_dyad <- length(cond_suff_mat[,1])
FI = num_of_dyad * res$mple_cov
FI
solve(FI)
sqrt(0.05149117)
library(matrixsqrtinv )
install.packages("matrixsqrtinv")
library(matrixsqrtinv )
library(matrixsqrtinv)
# function to compute the inverse square root of a matrix
fnMatSqrtInverse = function(mA) {
ei = eigen(mA)
d = ei$values
d = (d+abs(d))/2
d2 = 1/sqrt(d)
d2[d == 0] = 0
return(ei$vectors %*% diag(d2) %*% t(ei$vectors))
}
fnMatSqrtInverse(solve(FI))
fnMatSqrtInverse(FI)
sovle(FI)
solve(FI)
sqrt(solve(FI))
sqrt(0.04809095)
mA = FI
ei = eigen(mA)
ei
mA %*% ei$vectors[:,1]
mA %*% ei$vectors[,1]
417.007889*ei$vectors[,1]
d = (d+abs(d))/2
d = ei$values
d = (d+abs(d))/2
d
d2 = 1/sqrt(d)
d2
d2[d == 0] = 0
d2
diag(d2)
fnMatSqrtInverse(FI)
diag(fnMatSqrtInverse(FI))
sqrtm
library(expm)
install.packages("expm")
library(expm)
sqrtm(FI)
sqrt(FI)
sqrt(diag(FI))
############################################################
### test of standard error  ################################
############################################################
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
RNETWORK <- rcpp_simulate_ml_Hway(samp_num, burnin, intv, mdim, mterm, N, k, theta, H, seed,basis_arguments)
samp_num = 1
# calculate covariance matrix of mple by sufficient statistics
a <- rcpp_compute_dyad_suffstats(NetMat, samp_num, burnin, intv, mdim, mterm, N, k, H, seed,basis_arguments)
RNETWORK <- rcpp_simulate_ml_Hway(samp_num, burnin, intv, mdim, mterm, N, k, theta, H, seed,basis_arguments)
NetMat <- RNETWORK$elist
# calculate covariance matrix of mple by sufficient statistics
a <- rcpp_compute_dyad_suffstats(NetMat, samp_num, burnin, intv, mdim, mterm, N, k, H, seed,basis_arguments)
a
suff_matrix <- a$dyad_suffstats
df <- data.frame(suff_matrix)
# only count sufficient statistics of the individual activated dyad
cond_suff_mat <- df[rowSums(df[,3:(mdim+2)]) > 0,]
cond_suff_mat
mple_cov <- cov(cond_suff_mat[,3:(mdim+2)])
num_of_dyad <- length(cond_suff_mat[,1])
FI <- num_of_dyad * mple_cov # Fisher information matrix for the mlnet given Y at theta = \mple
suff_stats_sd <- diag(sqrtm(FI)) # take matrix square root of FI
suff_stats_sd
colSums(cond_suff_mat[,3:(mdim+2)])
RNETWORK$suff_list
suff_stats <- colSums(cond_suff_mat[,3:(mdim+2)])
suff_stats
suff_stats[1]
suff_stats[1]+1
View(suff_matrix)
suff_stats <- colSums(cond_suff_mat[,3:(mdim+2)])
names(suff_stats) <- NULL
suff_stats
############################################################
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
View(mlnet)
## Sample and estimate the multilayer network sampled above
estimates <- est_ml(NetMat = mlnet$net, N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed, basis_arguments = basis_arguments)
View(estimates)
summary_est(estimates)
theta
sim_est_res <- sim_est(theta,N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed,basis_arguments =basis_arguments)
View(sim_est_res)
summary_est(estimates)
matrix(theta_est, ncol = 6)
matrix(theta, ncol = 6)
matrix(c(theta,theta), ncol = 6)
matrix(c(theta,theta), ncol = 6, byrow = TRUE)
############################################################
### test of standard error  ################################
############################################################
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
summary(mlnet)
summary_sim(mlnet)
############################################################
### test of standard error  ################################
############################################################
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
summary_sim(mlnet)
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
summary_sim(mlnet)
## Sample and estimate the multilayer network sampled above
estimates <- est_ml(NetMat = mlnet$net, N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed, basis_arguments = basis_arguments)
summary_est(estimates)
sim_est_res <- sim_est(theta,N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed,basis_arguments =basis_arguments)
summary_est(sim_est_res)
summary_sim(sim_est_res)
summary_sim(sim_est_res)
devtools::document()
sim_est_res <- sim_est(theta,N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed,basis_arguments =basis_arguments)
summary_sim(sim_est_res)
summary_est(sim_est_res)
## plot the k-layer multilayer network sampled above
draw_mlnet(mlnet$net,N)
devtools::document()
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
rm(list = ls())
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 4  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
sim_est_res <- sim_est(theta,N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed,basis_arguments =basis_arguments)
devtools::document()
sim_est_res <- sim_est(theta,N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed,basis_arguments =basis_arguments)
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
library("devtools")
devtools::document()
set.seed(123456)
seed <- sample(1:9999999,1,replace = FALSE)
N <- 50 # number of nodes
## Parameter settings
burnin <- 100
k <- 3  # number of layers, okay to change
H <- 2  # highest order of interactions, okay to change (<= k)
mdim <- 0
for(i in 1:H){
mdim <- mdim + choose(k,i)
}
intv <- 3 # sampling iterval
iter_max <- 30000 # maximum iterations for estimation
dyads <- 1000
# generate stochastic block model basis as an example
# can be set to 'Ber', 'LSM' and 'other'
mterm <- 'BER'
gy <- dyads / choose(N,2)
# set basis network arguments for SBM basis
basis_arguments <- c(gy, seed)
# generate theta for layers
params <- matrix(runif(mdim,-1,1),1,mdim)
params[,c(3,6)] = 0
theta <- params[1,]
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = mterm, basis_arguments = basis_arguments)
Rcpp.package.skeleton("mlyrnetwork")
library(Rcpp)
Rcpp.package.skeleton("mlyrnetwork")
library("devtools")
devtools::document()
## Sample a k-layer multilayer network
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = 'SBM', basis_arguments = basis_arguments)
usethis::use_package("expm")
devtools::document()
usethis::use_package("expm")
library("devtools")
devtools::document()
setwd("C:/Users/ljhhe/OneDrive - Florida State University/GitHub/mlyrnetwork")
#usethis::use_package("expm")
library("devtools")
devtools::document()
#usethis::use_package("expm")
library("devtools")
devtools::document()
## Sample a k-layer multilayer network
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = 'SBM', basis_arguments = basis_arguments)
#usethis::use_package("expm")
library("devtools")
devtools::document()
## Sample a k-layer multilayer network
mlnet <- samp_ml(theta,N = N, k = k, H = H ,mdim = mdim, seed = seed, mterm = 'SBM', basis_arguments = basis_arguments)
summary_sim(mlnet)
## plot the k-layer multilayer network sampled above
draw_mlnet(mlnet$net,N)
## Sample and estimate the multilayer network sampled above
estimates <- est_ml(NetMat = mlnet$net, N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed, basis_arguments = basis_arguments)
### Add standard errors ###
summary_est(estimates)
## Examples of invalid input
est_ml(NetMat = mlnet$net, N = N, k = k, H = k+1, mdim = mdim, mterm = mterm,
seed = seed, basis_arguments = basis_arguments)
sim_est_res <- sim_est(theta,N = N, k = k, H = H, mdim = mdim, mterm = mterm,
seed = seed,basis_arguments =basis_arguments)
summary_sim(sim_est_res)
summary_est(sim_est_res)
## Examples of data analysis using the Lazega lawyer network data set
obs <- compute_suffstats_Lazega() # compute the observed sufficient statistics from the Lazega network.
# compute the basis network of Lazega
unique_dyads <- unique(Lazega_lawyer_network[,1:2])
unique_dyads_vec <- as.vector(t(unique_dyads))
# estimate ERGM model parameters using MPLE.
data_res <- est_ml(NetMat = Lazega_lawyer_network, N = 71, k = 3, H = 2, mdim = 6, mterm = 'other',
seed = seed, basis_arguments = unique_dyads_vec)
# obtain the estimated theta for Lazega network
data_theta <- data_res$theta_est
summary_est(data_res)
